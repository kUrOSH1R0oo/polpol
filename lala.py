# app.py
from flask import Flask, render_template, request, session, Response
from flask_socketio import SocketIO, emit, join_room, leave_room
import secrets
import random
import hmac
from datetime import datetime
import json
import os
import hashlib
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
import base64

app = Flask(__name__)
app.config['SECRET_KEY'] = secrets.token_urlsafe(32)
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16MB max file size

socketio = SocketIO(app, async_mode='gevent')

# In-memory storage
users = {}           # sid -> username
rate_limits = {}

# Secret configuration (for the challenge)
# This should match what you used in encode.py
SECRET_WORD = "3AND5"  # Change this to your actual secret word

# Encrypted flag (generated by encode.py)
# This should be the output from encode.py
ENCRYPTED_FLAG = "VujsICBz0LV15TIAJ4JnNGptp34XARCOT0PkFHKhtwzZ6tzPt6orr6e47S9FDlY2TBNaaZXyo9CPkyV3jWxWsQ=="

def decrypt_flag(secret_word: str, encrypted_flag: str) -> str:
    """
    Decrypt the flag using AES-256-CBC with the secret word as key
    """
    try:
        # Create a 256-bit key from the secret word using SHA-256
        key = hashlib.sha256(secret_word.encode()).digest()
        
        # Decode the base64 encrypted data
        encrypted_data = base64.b64decode(encrypted_flag)
        
        # Extract IV (first 16 bytes) and ciphertext
        iv = encrypted_data[:16]
        ciphertext = encrypted_data[16:]
        
        # Create AES cipher in CBC mode
        cipher = AES.new(key, AES.MODE_CBC, iv)
        
        # Decrypt and unpad
        decrypted = cipher.decrypt(ciphertext)
        unpadded = unpad(decrypted, AES.block_size)
        
        return unpadded.decode('utf-8')
    except Exception as e:
        # If decryption fails, return a generic error message
        # or the encrypted flag itself for debugging
        return f"Decryption failed: {str(e)}"


# Conversation history storage
HISTORY_FILE = "chat_history.json"


def load_history():
    """Load conversation history from file"""
    if os.path.exists(HISTORY_FILE):
        try:
            with open(HISTORY_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        except:
            return []
    return []


def save_history(message):
    """Save a message to history file"""
    history = load_history()
    history.append(message)
    
    # Keep only last 1000 messages
    if len(history) > 1000:
        history = history[-1000:]
    
    with open(HISTORY_FILE, 'w', encoding='utf-8') as f:
        json.dump(history, f, indent=2, ensure_ascii=False)


def generate_username():
    adjectives = ["Swift", "Silent", "Quick", "Bright", "Calm", "Wise",
                  "Shadow", "Blaze", "Frost", "Storm", "Void", "Neon", "Ghost"]
    animals = ["Fox", "Wolf", "Bear", "Eagle", "Lion", "Tiger",
               "Panther", "Hawk", "Raven", "Dragon", "Cat", "Shark"]
    return f"{random.choice(adjectives)}_{random.choice(animals)}_{random.randint(100, 999)}"


@app.route('/', methods=['GET', 'POST'])
def index():
    if request.method == 'POST':
        username = request.form.get('username', '').strip()
        if username:
            # Basic sanitization - limit length + remove dangerous chars
            username = username[:32].replace('<', '').replace('>', '')
            if username:
                session['username'] = username
        return Response(status=204)  # No content - success

    # GET request - show chat
    if 'username' not in session:
        session['username'] = generate_username()

    history = load_history()

    return render_template('chat.html',
                         username=session['username'],
                         history=history)


@socketio.on('connect')
def handle_connect():
    sid = request.sid
    username = session.get('username')
    
    if not username or sid in users:
        return False
    
    users[sid] = username
    join_room('chatroom')
    
    emit('system', {
        'msg': f'{username} joined the chat',
        'time': datetime.now().isoformat()
    }, room='chatroom')


@socketio.on('disconnect')
def handle_disconnect():
    sid = request.sid
    username = users.pop(sid, None)
    
    if username:
        leave_room('chatroom')
        emit('system', {
            'msg': f'{username} left the chat',
            'time': datetime.now().isoformat()
        }, room='chatroom')


@socketio.on('message')
def handle_message(data):
    sid = request.sid
    username = users.get(sid)
    
    if not username:
        return
    
    msg = data.get('msg', '').strip()
    
    if not msg or len(msg) > 500:
        return
    
    message_data = {
        'type': 'chat',
        'user': username,
        'msg': msg,
        'time': datetime.now().isoformat()
    }
    
    # Save to persistent history
    save_history(message_data)
    
    # Broadcast to others
    emit('chat', message_data, room='chatroom', include_self=False)
    
    # Send back to sender (same format!)
    emit('chat', message_data, to=sid)
    
    # Secret word check (case insensitive)
    if hmac.compare_digest(msg.lower(), SECRET_WORD.lower()):
        # Decrypt the flag when the secret word is entered
        decrypted_flag = decrypt_flag(SECRET_WORD, ENCRYPTED_FLAG)
        
        emit('private', {
            'msg': f'Flag: {decrypted_flag}',
            'time': datetime.now().isoformat()
        }, to=sid)


if __name__ == '__main__':
    print("Terminal Chat Server starting...")
    print("URL: http://localhost:4444")
    
    # Load the actual encrypted flag from file if exists
    if os.path.exists("encrypted_flag.txt"):
        with open("encrypted_flag.txt", "r") as f:
            ENCRYPTED_FLAG = f.read().strip()
        print(f"Loaded encrypted flag (length: {len(ENCRYPTED_FLAG)})")
    
    socketio.run(app, host='0.0.0.0', port=4444, debug=False, allow_unsafe_werkzeug=True)